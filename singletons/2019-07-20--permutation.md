
#### Question
Express the permutations of elements in a list.

```clojure

(defn without [vec elem]
    (for [x vec :when (not (= x elem))] x))


(defn perms [freevec choices]
  (if (= 1 (count freevec))
      ; choices + freevec[0]
      (conj choices (first freevec))
      
      ; otherwise
      (for [elem freevec]
            (perms 
                  ; rest => freevec - elem
                  (without freevec elem)
                  (conj choices elem)
                  ))
      )
)

```

* ==> first stab
```clojure
user=> (perms [1 2 3] [])
(([1 2 3] [1 3 2]) ([2 1 3] [2 3 1]) ([3 1 2] [3 2 1]))
```

* validate size...
```clojure
(defn factorial [n]
    (apply * 
        (without (range (inc n)) 0)
        ))
        
user=> (pprint (perms [1 2 3 4] []))
((([1 2 3 4] [1 2 4 3]) ([1 3 2 4] [1 3 4 2]) ([1 4 2 3] [1 4 3 2]))
 (([2 1 3 4] [2 1 4 3]) ([2 3 1 4] [2 3 4 1]) ([2 4 1 3] [2 4 3 1]))
 (([3 1 2 4] [3 1 4 2]) ([3 2 1 4] [3 2 4 1]) ([3 4 1 2] [3 4 2 1]))
 (([4 1 2 3] [4 1 3 2]) ([4 2 1 3] [4 2 3 1]) ([4 3 1 2] [4 3 2 1])))
nil

user=> (count (perms [1 2 3 4] []))
4
```

#### fix how the sequences are combined.
* Slight change, adding use of `(vec )` to try to combine... 
* So `vec` sort of should work to at least exhause a sequence into a vector..
```clojure
(defn perms [freevec choices]
  (if (= 1 (count freevec))
      ; choices + freevec[0]
      (conj choices (first freevec))
      
      ; otherwise
      (vec
        (for [elem freevec]
            (perms 
                  ; rest => freevec - elem
                  (without freevec elem)
                  (conj choices elem)
                  ))
            )))
```
* => not quite...   I guess its not 
```clojure
user=> (perms [1 2 3] [])
[[[1 2 3] [1 3 2]] [[2 1 3] [2 3 1]] [[3 1 2] [3 2 1]]]
```
* Another layer gets added for each additional permutation ... grrr..
```clojure
user=> (perms [1 2 3 4 5] [])
[[[[[1 2 3 4 5] [1 2 3 5 4]] [[1 2 4 3 5] [1 2 4 5 3]] [[1 2 5 3 4] [1 2 5 4 3]]] [[[1 3 2 4 5] [1 3 2 5 4]] [[1 3 4 2 5] [1 3 4 5 2]] [[1 3 5 2 4] [1 3 5 4 2]]] [[[1 4 2 3 5] [1 4 2 5 3]] [[1 4 3 2 5] [1 4 3 5 2]] [[1 4 5 2 3] [1 4 5 3 2]]] [[[1 5 2 3 4] [1 5 2 4 3]] [[1 5 3 2 4] [1 5 3 4 2]] [[1 5 4 2 3] [1 5 4 3 2]]]] [[[[2 1 3 4 5] [2 1 3 5 4]] [[2 1 4 3 5] [2 1 4 5 3]] [[2 1 5 3 4] [2 1 5 4 3]]] [[[2 3 1 4 5] [2 3 1 5 4]] [[2 3 4 1 5] [2 3 4 5 1]] [[2 3 5 1 4] [2 3 5 4 1]]] [[[2 4 1 3 5] [2 4 1 5 3]] [[2 4 3 1 5] [2 4 3 5 1]] [[2 4 5 1 3] [2 4 5 3 1]]] [[[2 5 1 3 4] [2 5 1 4 3]] [[2 5 3 1 4] [2 5 3 4 1]] [[2 5 4 1 3] [2 5 4 3 1]]]] [[[[3 1 2 4 5] [3 1 2 5 4]] [[3 1 4 2 5] [3 1 4 5 2]] [[3 1 5 2 4] [3 1 5 4 2]]] [[[3 2 1 4 5] [3 2 1 5 4]] [[3 2 4 1 5] [3 2 4 5 1]] [[3 2 5 1 4] [3 2 5 4 1]]] [[[3 4 1 2 5] [3 4 1 5 2]] [[3 4 2 1 5] [3 4 2 5 1]] [[3 4 5 1 2] [3 4 5 2 1]]] [[[3 5 1 2 4] [3 5 1 4 2]] [[3 5 2 1 4] [3 5 2 4 1]] [[3 5 4 1 2] [3 5 4 2 1]]]] [[[[4 1 2 3 5] [4 1 2 5 3]] [[4 1 3 2 5] [4 1 3 5 2]] [[4 1 5 2 3] [4 1 5 3 2]]] [[[4 2 1 3 5] [4 2 1 5 3]] [[4 2 3 1 5] [4 2 3 5 1]] [[4 2 5 1 3] [4 2 5 3 1]]] [[[4 3 1 2 5] [4 3 1 5 2]] [[4 3 2 1 5] [4 3 2 5 1]] [[4 3 5 1 2] [4 3 5 2 1]]] [[[4 5 1 2 3] [4 5 1 3 2]] [[4 5 2 1 3] [4 5 2 3 1]] [[4 5 3 1 2] [4 5 3 2 1]]]] [[[[5 1 2 3 4] [5 1 2 4 3]] [[5 1 3 2 4] [5 1 3 4 2]] [[5 1 4 2 3] [5 1 4 3 2]]] [[[5 2 1 3 4] [5 2 1 4 3]] [[5 2 3 1 4] [5 2 3 4 1]] [[5 2 4 1 3] [5 2 4 3 1]]] [[[5 3 1 2 4] [5 3 1 4 2]] [[5 3 2 1 4] [5 3 2 4 1]] [[5 3 4 1 2] [5 3 4 2 1]]] [[[5 4 1 2 3] [5 4 1 3 2]] [[5 4 2 1 3] [5 4 2 3 1]] [[5 4 3 1 2] [5 4 3 2 1]]]]]
```

#### Hmm.
* These have different results..
```clojure
user=> (apply concat [[[5 4 1 2 3] [5 4 1 3 2]] [[5 4 2 1 3] [5 4 2 3 1]] [[5 4 3 1 2] [5 4 3 2 1]]])
([5 4 1 2 3] [5 4 1 3 2] [5 4 2 1 3] [5 4 2 3 1] [5 4 3 1 2] [5 4 3 2 1])
user=> 

user=> (apply concat [[5 4 1 2 3] [5 4 1 3 2]])
(5 4 1 2 3 5 4 1 3 2)
```
* ... slightly hacky but I think I got it... 
```clojure
(defn perms [freevec choices]
  (if (= 1 (count freevec))
      (conj choices (first freevec))
      
      ; otherwise
      (let [res
                (vec
                    (for [elem freevec]
                        (perms 
                              (without freevec elem)
                              (conj choices elem)
                              )))
        ]
        (if (< (count freevec) 3)
            res
            (apply concat res))
        )
      ))
            
```
* output makes sense ... 
```clojure

user=> (perms [1 2 ] [])
[[1 2] [2 1]]
user=> 

user=> (perms [1 2 3] [])
([1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1])
user=> (perms [1 2 3 4] [])
([1 2 3 4] [1 2 4 3] [1 3 2 4] [1 3 4 2] [1 4 2 3] [1 4 3 2] [2 1 3 4] [2 1 4 3] [2 3 1 4] [2 3 4 1] [2 4 1 3] [2 4 3 1] [3 1 2 4] [3 1 4 2] [3 2 1 4] [3 2 4 1] [3 4 1 2] [3 4 2 1] [4 1 2 3] [4 1 3 2] [4 2 1 3] [4 2 3 1] [4 3 1 2] [4 3 2 1])
user=> (perms [1 2 3 4 5] [])
([1 2 3 4 5] [1 2 3 5 4] [1 2 4 3 5] [1 2 4 5 3] [1 2 5 3 4] [1 2 5 4 3] [1 3 2 4 5] [1 3 2 5 4] [1 3 4 2 5] [1 3 4 5 2] [1 3 5 2 4] [1 3 5 4 2] [1 4 2 3 5] [1 4 2 5 3] [1 4 3 2 5] [1 4 3 5 2] [1 4 5 2 3] [1 4 5 3 2] [1 5 2 3 4] [1 5 2 4 3] [1 5 3 2 4] [1 5 3 4 2] [1 5 4 2 3] [1 5 4 3 2] [2 1 3 4 5] [2 1 3 5 4] [2 1 4 3 5] [2 1 4 5 3] [2 1 5 3 4] [2 1 5 4 3] [2 3 1 4 5] [2 3 1 5 4] [2 3 4 1 5] [2 3 4 5 1] [2 3 5 1 4] [2 3 5 4 1] [2 4 1 3 5] [2 4 1 5 3] [2 4 3 1 5] [2 4 3 5 1] [2 4 5 1 3] [2 4 5 3 1] [2 5 1 3 4] [2 5 1 4 3] [2 5 3 1 4] [2 5 3 4 1] [2 5 4 1 3] [2 5 4 3 1] [3 1 2 4 5] [3 1 2 5 4] [3 1 4 2 5] [3 1 4 5 2] [3 1 5 2 4] [3 1 5 4 2] [3 2 1 4 5] [3 2 1 5 4] [3 2 4 1 5] [3 2 4 5 1] [3 2 5 1 4] [3 2 5 4 1] [3 4 1 2 5] [3 4 1 5 2] [3 4 2 1 5] [3 4 2 5 1] [3 4 5 1 2] [3 4 5 2 1] [3 5 1 2 4] [3 5 1 4 2] [3 5 2 1 4] [3 5 2 4 1] [3 5 4 1 2] [3 5 4 2 1] [4 1 2 3 5] [4 1 2 5 3] [4 1 3 2 5] [4 1 3 5 2] [4 1 5 2 3] [4 1 5 3 2] [4 2 1 3 5] [4 2 1 5 3] [4 2 3 1 5] [4 2 3 5 1] [4 2 5 1 3] [4 2 5 3 1] [4 3 1 2 5] [4 3 1 5 2] [4 3 2 1 5] [4 3 2 5 1] [4 3 5 1 2] [4 3 5 2 1] [4 5 1 2 3] [4 5 1 3 2] [4 5 2 1 3] [4 5 2 3 1] [4 5 3 1 2] [4 5 3 2 1] [5 1 2 3 4] [5 1 2 4 3] [5 1 3 2 4] [5 1 3 4 2] [5 1 4 2 3] [5 1 4 3 2] [5 2 1 3 4] [5 2 1 4 3] [5 2 3 1 4] [5 2 3 4 1] [5 2 4 1 3] [5 2 4 3 1] [5 3 1 2 4] [5 3 1 4 2] [5 3 2 1 4] [5 3 2 4 1] [5 3 4 1 2] [5 3 4 2 1] [5 4 1 2 3] [5 4 1 3 2] [5 4 2 1 3] [5 4 2 3 1] [5 4 3 1 2] [5 4 3 2 1])
user=> (count (perms [1 2 3 4 5] []))
120
user=> (count (perms [1 2 3 4 5] []))

user=> (factorial 5)
120
```
